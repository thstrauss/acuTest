#include <string.h>#include <stdlib.h>#include <stdio.h>
#include <portab.h>
#include <tos.h>

#define PH_MAGIC 0x601a

typedef struct PH_{   WORD  ph_branch;        /* Branch zum Anfang des Programms  */                           /* (muss 0x601a sein!)               */   LONG  ph_tlen;          /* Länge  des TEXT - Segments       */   LONG  ph_dlen;          /* Länge  des DATA - Segments       */   LONG  ph_blen;          /* Länge  des BSS  - Segments       */   LONG  ph_slen;          /* Länge  der Symboltabelle         */   LONG  ph_res1;          /* reserviert, sollte 0 sein        */                           /* wird von PureC benötigt          */   LONG  ph_prgflags;      /* Programmflags                    */   WORD  ph_absflag;       /* 0 = Relozierungsinf. vorhanden   */} PH;typedef unsigned char U8;typedef signed char   S8;typedef unsigned int  U16;typedef signed int    S16;typedef unsigned long U32;typedef signed long   S32;static void relocate(const void* code, const U8* relocData){	U8 *	lpText;	U8 *	lpRelocTable;	U8		lFix;	U32		lOffset;	lpText  = (U8*) code;	lpRelocTable  = (U8*) relocData;	lOffset = *(U32*)lpRelocTable;	lpRelocTable += sizeof(U32*);	if( lOffset )	{		*(U32*)&lpText[ lOffset ] += (U32)lpText;		while( *lpRelocTable )		{			lFix = *lpRelocTable++;			if( 1 == lFix )			{				lOffset += 254;			}			else			{				lOffset += lFix;				*(U32*)&lpText[ lOffset ] += (U32)lpText;			}		};	}}static void*load_and_reloc(long handle, long fsize, PH* phead, long* cmplt_size){    void* addr = NULL;    long TD_len, TDB_len;    /* Laenge von Text- und Data-Segment */    TD_len = phead->ph_tlen + phead->ph_dlen;    /* Laenge von Text-, Data- und BSS-Segment */    TDB_len = TD_len + phead->ph_blen;    *cmplt_size = TDB_len;
        /* Speicher fuer Text-, Data- und BSS-Segment anfordern */    addr = malloc(TDB_len);    if (addr)    {        long relo_len;        /* Laenge der Relokationsdaten */        relo_len = fsize - sizeof(PH) - TD_len - phead->ph_slen;        /* Text- und Data-Segment laden */        if (Fread((int)handle, TD_len, addr) == TD_len)        {               /* Symboltabelle ueberspringen */            Fseek(phead->ph_slen, (int)handle, 1);            /* BSS-Segment loeschen */            memset((char*)addr + TD_len, 0, phead->ph_blen);            /* Datei relozieren */            if ((phead->ph_absflag == 0) && relo_len)            {                unsigned char* relo_mem;
                /* Speicher fuer Relokationsdaten anfordern */                relo_mem = malloc(relo_len);                if (relo_mem)                {                    if (Fread((int)handle, relo_len, relo_mem) == relo_len)                    {						relocate(addr, relo_mem);                    }                    else                    {                        free(addr);                        addr = NULL;                    }                    /* Speicher fuer Relokationsdaten freigeben */                    free(relo_mem);                }                else                {                    free(addr);                    addr = NULL;                }            }        }        else        {            free(addr);            addr = NULL;        }    }    return addr;}void*load_cu(const char* cu_name, long* cmplt_size){    void* addr = NULL;    long handle;
    long filesize;    handle = Fopen(cu_name, O_RDONLY);    if (handle > 0)    {        PH phead;
                /* load program header */        if (Fread((int)handle, sizeof(phead), &phead) == sizeof(phead))        {            /* bra.s am Anfang? */            if (phead.ph_branch == PH_MAGIC)
            	filesize = Fseek(0, (int) handle, 2);
            	Fseek(sizeof(PH), (int) handle, 0);
                            /* load and relocate */                addr = load_and_reloc(handle, filesize, &phead, cmplt_size);        }        Fclose((short)handle);    } else {
    	printf("%s not opened", cu_name);
    }    return addr;}void unload_cu(void* addr){    free(addr);}